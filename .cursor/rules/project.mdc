---
description: 
globs: 
alwaysApply: true
---
# AI Agents Playing Risk - Project Documentation

## üìú Project Overview

This project develops **AI agents that play the classic board game Risk against each other** using Ollama's function calling capabilities. The system consists of:

### **Core Components:**
- **AI Agent System** (Python) - The main focus of this repository
- **Risk API Server** (Rust) - External dependency providing game logic
- **Risk UI** (React) - External dependency for game visualization

### **External Dependencies (Do Not Modify):**
- **Risk API Server**: Rust-based REST API running on port 8000 (cloned from https://github.com/Krilecy/risk-board_game-server)
- **Risk UI**: React-based frontend for visualization (cloned from https://github.com/Krilecy/risk-ui)

### **This Repository Focus:**
- AI agent implementations and orchestration
- Function calling integration with Ollama
- Multi-agent game management
- Strategic gameplay development

## üéØ Core Goals

1. **AI Agent Development**: Create intelligent agents that can play Risk autonomously
2. **Function Calling Integration**: Use Ollama (with function calling) for API interactions
3. **Multi-Agent Competition**: Enable 2-6 AI agents to play against each other
4. **Strategic Gameplay**: Develop agents with different strategies and personalities
5. **Observable Gameplay**: Use the existing UI to visualize AI agent games

## üèóÔ∏è Project Architecture

### **Directory Structure**
```
risk/
‚îú‚îÄ‚îÄ agents/                    # AI agent implementations and orchestration
‚îÇ   ‚îú‚îÄ‚îÄ simple_agent.py       # Main agent implementation with strategies
‚îÇ   ‚îú‚îÄ‚îÄ ollama_client.py      # Ollama integration and function calling
‚îÇ   ‚îú‚îÄ‚îÄ game_orchestrator.py  # Multi-agent game management
‚îÇ   ‚îú‚îÄ‚îÄ risk_api.py           # Risk API client and data structures
‚îÇ   ‚îî‚îÄ‚îÄ risk_rules.py         # Game rule validation and action generation
‚îú‚îÄ‚îÄ risk-board_game-server/   # Risk API server (external, unchanged)
‚îú‚îÄ‚îÄ Risk-UI/                  # React frontend (external, unchanged)
‚îú‚îÄ‚îÄ main.py                   # Main entry point and game setup
‚îú‚îÄ‚îÄ game_config.json          # Default game configuration
‚îî‚îÄ‚îÄ custom_players.json       # Custom player configurations
```

### **Key Components**

#### **1. Agent System**
- **SimpleAgent**: Base agent with configurable strategies
- **AggressiveAgent**: Attack-focused strategy
- **DefensiveAgent**: Defense-focused strategy

#### **2. Function Calling Integration**
- **OllamaAgentClient**: Handles Ollama API calls with function calling
- **Function Definitions**: Risk API function schemas
- **Error Handling**: Robust error handling and retry logic

#### **3. Game Orchestration**
- **GameOrchestrator**: Manages multi-agent games and turn flow
- **Phase Management**: Reinforce ‚Üí Attack ‚Üí Fortify ‚Üí Move Armies
- **State Management**: Fresh game state for each decision

## üéÆ Risk Game Rules

### **Game Setup**
- **Players**: 2-6 players
- **Territories**: 42 territories across 6 continents
- **Initial Armies**: Varies by player count (typically 20-35 per player)
- **Victory Condition**: Control all territories (eliminate all other players)

### **Game Phases & Turn Flow**

#### **1. Reinforce Phase**
- **Base Reinforcements**: `max(territories_owned / 3, 3)` armies
- **Continent Bonuses**: +2 to +7 armies for controlling entire continents
- **Card Trading**: Trade 3 cards for bonus armies (see Card System)
- **Possible Actions**: `Reinforce` actions for each territory, `EndPhase` to advance
- **API Actions**: `reinforce()`, `trade_cards()`, `advance_phase()` (calls EndPhase)

#### **2. Attack Phase**
- **Attack Rules**: Attack from territories with >1 army to adjacent enemy territories
- **Dice Rolling**: 1-3 dice for attacker, 1-2 dice for defender
- **Conquest**: If defender loses all armies, territory is conquered
- **Possible Actions**: `Attack` actions for valid attacks, `EndPhase` to advance
- **API Actions**: `attack()`, `advance_phase()` (calls EndPhase)

#### **3. Fortify Phase**
- **Movement**: Move armies between connected territories you control
- **Connection**: Territories must be connected via your controlled territories
- **Restrictions**: Must leave at least 1 army in source territory
- **Possible Actions**: `Fortify` actions for valid moves, `EndPhase` to advance
- **API Actions**: `fortify()`, `advance_phase()` (calls EndPhase)

#### **4. Move Armies Phase** (After Conquest)
- **Trigger**: Automatically after successful territory conquest
- **Movement**: Move armies from attacking territory to conquered territory
- **Minimum**: Must move at least the number of dice used in attack
- **Possible Actions**: `MoveArmies` action with specific parameters
- **API Actions**: `move_armies()`

### **Important API Behavior**

#### **Player Identification**
- **Current Player**: API returns `"Player 1"`, `"Player 2"`, etc. (strings)
- **Player IDs**: Must be converted to integers (0, 1, 2, etc.) for API calls
- **Mapping**: `"Player 1"` ‚Üí `0`, `"Player 2"` ‚Üí `1`, etc.

#### **Phase Advancement**
- **API Endpoint**: `POST /advance_phase` 
- **Internal Action**: API calls `EndPhase` action internally
- **Validation**: Only available when `"EndPhase"` appears in possible_actions
- **Required**: Must complete all required actions before advancing

#### **Possible Actions Structure**
```json
{
  "possible_actions": [
    {"Reinforce": {"territory": "Alaska", "max_armies": 3}},
    {"Attack": {"from": "Alaska", "to": "Northwest Territory", "max_dice": 2}},
    {"Fortify": {"from": "Quebec", "to": "Ontario", "max_armies": 2}},
    {"MoveArmies": {"from": "Alaska", "to": "Northwest Territory", "max_armies": 2}},
    "EndPhase"
  ]
}
```

#### **Game State Structure**
```json
{
  "game_state": {
    "current_player": "Player 1",
    "current_phase": null,  // API doesn't expose phase name
    "reinforcement_armies": 3,
    "players": [
      {
        "id": 0,
        "name": "Bob",
        "territories": ["Alaska", "Quebec", ...],
        "armies": {"Alaska": 5, "Quebec": 3, ...},
        "cards": []
      }
    ],
    "board": {
      "territories": {
        "Alaska": {
          "adjacent_territories": ["Northwest Territory", "Alberta", "Kamchatka"]
        }
      },
      "continents": {
        "North America": {
          "territories": ["Alaska", "Northwest Territory", ...],
          "bonus_armies": 5
        }
      }
    },
    "possible_actions": [...],
    "conquered_territory": false,
    "game_over": false
  }
}
```

### **Continent System**
| Continent | Territories | Bonus Armies |
|-----------|-------------|--------------|
| North America | 9 | +5 |
| South America | 4 | +2 |
| Europe | 7 | +5 |
| Africa | 6 | +3 |
| Asia | 12 | +7 |
| Australia | 4 | +2 |

### **Card System**

#### **Card Types:**
- **Infantry** (‚ô†Ô∏è) - Territory cards
- **Cavalry** (‚ô£Ô∏è) - Territory cards  
- **Artillery** (‚ô•Ô∏è) - Territory cards
- **Joker** (üÉè) - Can substitute for any card type

#### **Getting Cards:**
- **Conquest Reward**: Receive 1 card when conquering at least 1 territory
- **No Starting Cards**: Players start with 0 cards
- **Maximum Cards**: Players can hold unlimited cards

#### **Trading Cards for Armies:**
**Valid Trading Combinations:**
1. **Three of a Kind:**
   - 3 Infantry = 4 armies
   - 3 Cavalry = 6 armies  
   - 3 Artillery = 8 armies

2. **One of Each:**
   - 1 Infantry + 1 Cavalry + 1 Artillery = 10 armies

3. **With Jokers:**
   - Jokers can substitute for any card type
   - Any valid 3-card combination with jokers = 10 armies

#### **Territory Bonus:**
- When trading cards, if one traded card matches a territory you own
- **+2 bonus armies** automatically placed on that territory

#### **Trading Rules:**
- Must trade exactly 3 cards
- Can only trade during Reinforce Phase
- Cards are discarded after trading
- Can trade multiple times per turn if you have enough cards

## üîå Risk API Endpoints

### **Game State**
- `GET /game-state` - Retrieve current game state with possible actions
- `GET /` - API documentation

### **Game Actions**
- `POST /reinforce` - Add armies to a territory (only during Reinforce phase)
- `POST /bulk_reinforce` - Add armies to multiple territories
- `POST /attack` - Execute an attack between territories (only during Attack phase)
- `POST /fortify` - Move armies between connected territories (only during Fortify phase)
- `POST /move_armies` - Move armies after conquering a territory (only during Move Armies phase)
- `POST /trade_cards` - Trade in cards for additional armies (only during Reinforce phase)
- `POST /advance_phase` - Progress to the next phase (calls EndPhase internally)
- `POST /new-game` - Start a new game with optional configuration

### **Important API Behavior**

#### **Action Validation**
- **All actions are validated against `possible_actions`**
- **Actions can only be performed during their respective phases**
- **`advance_phase` only works when `"EndPhase"` is in possible_actions**
- **API returns 400/422 errors for invalid actions**

#### **Player ID Handling**
- **API expects integer player IDs (0, 1, 2, ...)**
- **Game state returns string player names (`"Player 1"`, `"Player 2"`, ...)**
- **Must convert: `"Player 1"` ‚Üí `0`, `"Player 2"` ‚Üí `1`, etc.**

### **API Request Formats**

#### **Reinforce**
```json
{
  "player_id": 0,
  "territory": "Alaska",
  "num_armies": 3
}
```
**Validation**: Territory must be in `Reinforce` possible_actions

#### **Attack**
```json
{
  "player_id": 0,
  "from_territory": "Alaska",
  "to_territory": "Northwest Territory",
  "num_dice": 2,
  "repeat": false
}
```
**Validation**: Attack must be in `Attack` possible_actions

#### **Fortify**
```json
{
  "player_id": 0,
  "from_territory": "Quebec",
  "to_territory": "Ontario",
  "num_armies": 2
}
```
**Validation**: Fortify must be in `Fortify` possible_actions

#### **Move Armies**
```json
{
  "player_id": 0,
  "from_territory": "Alaska",
  "to_territory": "Northwest Territory",
  "num_armies": 2
}
```
**Validation**: MoveArmies must be in possible_actions after conquest

#### **Trade Cards**
```json
{
  "player_id": 0,
  "card_indices": [0, 1, 2]
}
```
**Validation**: Only during Reinforce phase, must have 3+ cards

#### **Advance Phase**
```json
{
  "player_id": 0
}
```
**Validation**: Only when `"EndPhase"` is in possible_actions

#### **New Game**
```json
{
  "config_file": "game_config.json",
  "num_players": 3
}
```

## ü§ñ AI Agent Implementation

### **Current Implementation Status**

#### **‚úÖ Implemented Features**
- Basic Risk API client with function calling
- Ollama integration with llama3.2 model
- Base agent framework with strategy patterns
- Simple, aggressive, and defensive agent strategies
- Game orchestration and tournament management
- Basic reinforce, attack, fortify, and move armies functionality
- Game state parsing and analysis
- Error handling and timeout management
- Card trading system with validation
- Continent information and strategic guidance

### **Function Calling Integration**

#### **Ollama Function Definitions**
```python
functions = [
    FunctionDefinition(
        name="reinforce",
        description="Place armies on your territories",
        parameters={...}
    ),
    FunctionDefinition(
        name="attack", 
        description="Attack enemy territories",
        parameters={...}
    ),
    # ... other functions
]
```

## üö´ Important Workflow Rules

- **NEVER start games automatically**: Always wait for user feedback before running any game
- **Always ask for confirmation**: Before executing `python main.py` or any game commands, ask the user if they want to proceed
- **User controls execution**: The user should be the one to decide when to run games and test changes
- **Provide clear next steps**: After making changes, explain what the user can do to test them, but don't execute without permission

## üßë‚Äçü§ù‚Äçüßë Custom Player Names

- You can set custom player names by providing a custom game configuration file (JSON) and passing its path to the `/new-game` endpoint using the `config_file` parameter.
- The config file must define the `players` array, and each player object must have a `name` field.
- Example config snippet:

```json
{
  "players": [
    { "id": 0, "name": "Alice", ... },
    { "id": 1, "name": "Bob", ... }
  ],
  ...
}
```

- To start a game with these names, POST to `/new-game`:

```bash
curl -X POST http://localhost:8000/new-game \
  -H "Content-Type: application/json" \
  -d '{"config_file": "your_custom_config.json"}'
```

- The config file must be accessible to the server (in its working directory).
- **You cannot set player names directly via a parameter in the `/new-game` JSON payload.**

## üéØ Current Implementation Status

### ‚úÖ Implemented Features
- Basic Risk API client with function calling
- Ollama integration with llama3.2 model
- Base agent framework with strategy patterns
- Simple, aggressive, and defensive agent strategies
- Game orchestration and tournament management
- Basic reinforce and attack functionality
- Game state parsing and analysis
- Error handling and timeout management

## üßë‚Äçü§ù‚Äçüßë Custom Player Names

- You can set custom player names by providing a custom game configuration file (JSON) and passing its path to the `/new-game` endpoint using the `config_file` parameter.
- The config file must define the `players` array, and each player object must have a `name` field.
- Example config snippet:

```json
{
  "players": [
    { "id": 0, "name": "Alice", ... },
    { "id": 1, "name": "Bob", ... }
  ],
  ...
}
```

- To start a game with these names, POST to `/new-game`:

```bash
curl -X POST http://localhost:8000/new-game \
  -H "Content-Type: application/json" \
  -d '{"config_file": "your_custom_config.json"}'
```

- The config file must be accessible to the server (in its working directory).
- **You cannot set player names directly via a parameter in the `/new-game` JSON payload.**

## üÉè Card System in Risk

### **Card Types:**
- **Infantry** (‚ô†Ô∏è)
- **Cavalry** (‚ô£Ô∏è) 
- **Artillery** (‚ô•Ô∏è)
- **Joker** (üÉè) - Can substitute for any card type

### **Getting Cards:**
- **You only get cards by conquering territories**
- At the end of your turn, if you conquered at least one territory, you automatically receive one card from the deck
- **No cards are given at game start**

### **Trading Cards for Armies:**
Cards are primarily used to trade for additional reinforcement armies during the **Reinforce Phase**.

**Valid Trading Combinations:**
1. **Three of a Kind:**
   - 3 Infantry = 4 armies
   - 3 Cavalry = 6 armies  
   - 3 Artillery = 8 armies

2. **One of Each:**
   - 1 Infantry + 1 Cavalry + 1 Artillery = 10 armies

3. **With Jokers:**
   - Jokers can substitute for any card type
   - Any valid 3-card combination with jokers = 10 armies

### **Territory Bonus:**
When you trade cards, if one of the traded cards matches a territory you own, you get **+2 bonus armies** automatically placed on that territory.

### **Trading Rules:**
- Must trade exactly 3 cards
- Can only trade during the Reinforce Phase
- Cards are discarded after trading
- You can trade multiple times per turn if you have enough cards

### **Victory Condition:**
- **This implementation uses the classic Risk victory condition**: Control all territories on the board
- **No card-based missions** (like "Conquer Africa" or "Eliminate Red Player")
- The only way to win is to eliminate all other players

### **API Usage:**
```bash
# Trade cards for armies
curl -X POST http://localhost:8000/trade_cards \
  -H "Content-Type: application/json" \
  -d '{"player_id": 0, "card_indices": [0, 1, 2]}'
```

### **Key Differences from Classic Risk:**
- **No secret missions** - only territory control victory
- **No wild cards** - just jokers that substitute for any type
- **Simplified card system** - focused on army trading rather than objectives 

