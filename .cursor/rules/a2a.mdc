---
alwaysApply: true
---

# A2A (Agent-to-Agent) Protocol Rules & Findings

## Overview

A2A (Agent-to-Agent) is Google's protocol for AI agent communication. This document captures our findings, implementation patterns, and lessons learned from implementing A2A streaming in the Risk agent project.

**Key Architecture Insight**: A2A means **Agent-to-Agent** - the "clients" are other agents, not human users. In our case, a workflow agent will coordinate the game and maintain persistent connections to player agents.

## Implementation Choice: Streaming

**Decision**: We have opted for **streaming implementation** over non-streaming.

**Rationale**:
- **Real-time processing**: Game turns can be processed as they arrive
- **Connection reuse**: Persistent connections for entire game sessions
- **Better performance**: Lower latency for multi-turn interactions
- **Scalability**: Can handle multiple concurrent games efficiently

**Implications**:
- Clients (workflow agent) can close connections after receiving responses
- No need to wait for task completion events
- Connection pooling for multi-interaction sessions
- Simplified event handling (focus on message events)

## Key Findings

### 1. Streaming vs Non-Streaming Behavior

**Critical Discovery**: Clients have different expectations based on streaming mode:

- **Streaming Clients**: Can close connection immediately after receiving response message (process chunks as they arrive)
- **Non-Streaming Clients**: Must wait for task completion event (`TaskState.completed`) to know response is complete

**Evidence**: 
- A2A SDK provides `send_message()` for non-streaming requests that return complete responses
- Our client was timing out waiting for completion events that weren't being transmitted
- Solution: Modified client to close after response for streaming mode (since we're using streaming)

### 2. Event Transmission Issues

**Problem**: `TaskStatusUpdateEvent` with `TaskState.completed` is queued but not transmitted to clients.

**Evidence**:
- Server logs show: `[EXECUTE] Task completion event sent successfully`
- Client never receives completion event
- Curl tests confirm only message events reach client
- Ping events work, but completion events don't

**Root Cause**: A2A framework issue with `TaskStatusUpdateEvent` serialization/transmission

### 3. Event Format & Protocol

**JSON-RPC Format**:
```json
{
  "id": "request-id",
  "jsonrpc": "2.0",
  "result": {
    "kind": "message|status-update",
    "contextId": "uuid",
    "taskId": "uuid",
    // ... other fields
  }
}
```

**Event Types**:
- `kind: "message"` - Agent response content
- `kind: "status-update"` - Task state changes
- `: ping` - Keep-alive messages

### 4. Task States

Available task states in A2A:
- `submitted` - Task received
- `working` - Task in progress  
- `input-required` - Waiting for input
- `completed` - Task finished successfully
- `canceled` - Task cancelled
- `failed` - Task failed
- `rejected` - Task rejected
- `auth-required` - Authentication needed
- `unknown` - Unknown state

## Implementation Patterns

### 1. Agent Implementation

**Required Components**:
```python
from a2a.server.agent_execution import AgentExecutor
from a2a.server.request_handlers import DefaultRequestHandler
from a2a.server.tasks import InMemoryTaskStore
from a2a.server.apps import A2AStarletteApplication
from a2a.types import AgentCard, TaskState, TaskStatusUpdateEvent, Message, Role, Part, TextPart
```

**Agent Executor Pattern**:
```python
class PlayerAgentExecutor(AgentExecutor):
    async def execute(self, context, event_queue):
        # 1. Extract parameters from message parts
        # 2. Execute agent logic
        # 3. Send response message
        await event_queue.enqueue_event(Message(...))
        # 4. Send task completion (for streaming)
        await event_queue.enqueue_event(TaskStatusUpdateEvent(...))
```

### 2. Client Implementation

**Streaming Client Pattern**:
```python
# Process response and keep connection open for reuse
if data['result']['kind'] == 'message':
    agent_response = data['result']
    # Don't break - keep connection open for next request
    # Connection can be reused for multiple interactions
```

**Non-Streaming Client Pattern**:
```python
# Wait for both response and completion (wait for complete response)
if data['result']['kind'] == 'message':
    agent_response = data['result']
elif data['result']['kind'] == 'status-update':
    if data['result']['status']['state'] == 'completed':
        task_completed = True
        break
```

### 3. Connection Reuse Patterns

**Workflow Agent Pattern** (e.g., Risk game coordination):
```python
# Workflow agent keeps connections open to player agents
class WorkflowAgent:
    def __init__(self):
        self.player_connections = {}  # player_id -> A2A connection to player agent
    
    async def get_player_turn(self, player_id, turn_data):
        if player_id not in self.player_connections:
            # Establish new A2A connection to player agent
            self.player_connections[player_id] = await self.connect_to_player_agent(player_id)
        
        # Reuse existing A2A connection
        connection = self.player_connections[player_id]
        return await connection.send_turn_request(turn_data)
    
    async def close_game(self):
        # Close all A2A connections at game end
        for connection in self.player_connections.values():
            await connection.close()
```

**Benefits of Connection Reuse**:
- **Reduced overhead**: No repeated connection setup/teardown
- **State persistence**: Game context maintained across turns
- **Better performance**: Lower latency for subsequent requests
- **Resource efficiency**: Fewer active connections

**Connection Management**:
- **Connection pooling**: Reuse connections across multiple interactions
- **Session tracking**: Associate connections with game sessions
- **Error recovery**: Handle connection failures and reconnection
- **Cleanup**: Properly close connections when game ends

### 4. Workflow Agent Architecture

**Agent-to-Agent Coordination**:
```python
# Workflow agent coordinates multiple player agents
class RiskGameWorkflow:
    def __init__(self):
        self.player_agents = {
            1: "https://player-agent-1.a.run.app",
            2: "https://player-agent-2.a.run.app", 
            3: "https://player-agent-3.a.run.app"
        }
        self.connections = {}
    
    async def run_game(self):
        # Establish A2A connections to all player agents
        for player_id, agent_url in self.player_agents.items():
            self.connections[player_id] = await self.connect_to_agent(agent_url)
        
        # Game loop: coordinate turns between agents
        while not self.game_finished():
            current_player = self.get_current_player()
            turn_result = await self.get_player_turn(current_player)
            self.process_turn_result(turn_result)
        
        # Cleanup connections
        await self.close_all_connections()
```

**Benefits of Workflow Agent**:
- **Centralized coordination**: Single agent manages game flow
- **Persistent connections**: Maintain A2A connections throughout game
- **State management**: Track game state across multiple agent interactions
- **Error handling**: Centralized error recovery and retry logic
- **Scalability**: Can coordinate multiple games simultaneously

### 5. Agent Card Structure

**Required Fields** (Streaming Implementation):
```json
{
  "name": "Agent Name",
  "description": "Agent description",
  "url": "Agent endpoint",
  "version": "1.0.0",
  "protocolVersion": "0.2.5",
  "capabilities": {"streaming": true},  // We use streaming
  "skills": [
    {
      "id": "skill_id",
      "name": "Skill Name", 
      "description": "Skill description",
      "streaming": true,  // Skills support streaming
      "parameters": {
        "param_name": {
          "type": "string|integer|boolean",
          "description": "Parameter description",
          "required": true
        }
      }
    }
  ]
}
```

## Current Implementation Status

### Streaming Implementation

**Current State**: 
- ✅ **Agent Card**: Configured for streaming (`"streaming": true`)
- ✅ **Agent Executor**: Sends both message and completion events
- ✅ **Client**: Modified to close after response (streaming pattern)
- ❌ **Completion Events**: Not reaching clients (framework issue)

**Workaround**: 
- Use streaming pattern: close connection after receiving response
- Don't wait for task completion events
- Focus on message events for communication

## Known Issues & Workarounds

### 1. TaskStatusUpdateEvent Transmission

**Issue**: Completion events not reaching clients despite being queued successfully.

**Workaround**: 
- Use non-streaming mode for simple request-response
- Close client connection after receiving response message
- Don't wait for completion events

**Status**: Framework-level issue, needs investigation

### 2. Connection Timeouts

**Issue**: Clients timeout waiting for completion events that never arrive.

**Workaround**:
- Implement shorter timeouts for non-streaming clients
- Use immediate close after response pattern
- Add proper error handling for missing completion events

### 3. Event Parsing

**Issue**: Complex event structure with nested JSON-RPC format.

**Solution**:
- Implement robust JSON parsing with error handling
- Log all received events for debugging
- Handle unknown event types gracefully

## Best Practices

### 1. Client Design

- **Choose streaming mode carefully**: Use streaming for real-time processing, non-streaming for complete responses
- **Implement connection reuse**: Keep connections open for multi-interaction sessions (e.g., game sessions)
- **Implement proper timeouts**: Don't wait indefinitely for completion events in streaming mode
- **Handle connection errors**: Graceful degradation when events are missing
- **Log event flow**: Debug event transmission issues
- **Manage connection lifecycle**: Establish, reuse, and properly close connections

### 2. Agent Design

- **Always send completion events**: Even if clients don't wait for them
- **Use proper error handling**: Send appropriate task states for errors
- **Implement cancellation**: Handle client disconnections gracefully
- **Log event sending**: Track what events are being queued

### 3. Testing

- **Test with curl**: Verify event transmission manually
- **Monitor server logs**: Check event queuing and transmission
- **Test both modes**: Verify streaming and non-streaming behavior
- **Test error scenarios**: Handle missing parameters, timeouts, etc.

## Deployment Considerations

### 1. Environment Variables

```bash
# Required for A2A agent
export AGENT_CARD_URL="http://localhost:8080/"
export MCP_SERVER_URL="https://risk-mcp-server-jn3e4lhybq-ez.a.run.app/mcp/stream"
export GEMINI_MODEL="gemini-2.5-flash-lite-preview-06-17"
```

### 2. Docker Configuration

```dockerfile
# Expose A2A endpoint
EXPOSE 8080

# Health check for agent card
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:8080/.well-known/agent.json || exit 1
```

### 3. Cloud Run Deployment

- **Memory**: 2GB+ for Gemini model
- **CPU**: 2+ vCPUs for concurrent requests
- **Timeout**: 900s for long-running tasks
- **Concurrency**: 80 for streaming connections

## Future Investigations

### 1. Framework Issues

- Investigate why `TaskStatusUpdateEvent` transmission fails
- Check A2A framework version compatibility
- Report issues to A2A team if confirmed

### 2. Protocol Improvements

- Consider implementing custom event types
- Explore alternative completion signaling
- Investigate WebSocket vs HTTP streaming

### 3. Client Libraries

- Evaluate official A2A client libraries
- Consider implementing custom client with better error handling
- Explore A2A CLI tools for testing

## References

- [A2A Protocol Specification](https://a2a.dev/)
- [A2A Python SDK](https://github.com/google/a2a)
- [A2A JavaScript SDK](https://www.npmjs.com/package/@a2a-js/sdk)
- [Agent Cards Specification](https://a2a.dev/specification#agent-cards)

